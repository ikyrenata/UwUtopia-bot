/// <reference types="node" />
import { EventEmitter } from "events";
import { ChildProcess } from "child_process";
import { ObjectType } from './types/types';
/**
 * An HGCommandServer spawns the hg command server and
 * handles communication between it and node.
 * Piped output is then 'emitted' via the `EventEmitter`
 * subclass as `output`, `result` or `error` events.
*/
export declare type ChanNameType = "output" | "result" | "error" | "debug";
interface ConfigType extends ObjectType {
    hgOpts: string[];
}
export default class HGCommandServer extends EventEmitter {
    config: ConfigType;
    server?: ChildProcess;
    starting: boolean;
    [key: string]: any;
    constructor(config?: {});
    /**
     * Start the command server at
     * a specified directory (path must already be an hg repository)
     */
    start: (path: string, done: Function) => ChildProcess;
    /**
     * Stop the current command server process from running
     */
    stop: () => void;
    issueCommand: (cmd: string, ...args: any[]) => void;
    private _spawnCommandServer;
    /**
     * Create the child process (exposed for unit testing mostly)
     */
    private _makeHgProcess;
    /**
     * Parse the capabilities and encoding when the cmd server starts up
     */
    private _parseCapabilitiesAndEncoding;
    /**
     * Parse the Channel information, emit an event on the channel with the data.
     */
    private _handleServerData;
    private _handleServerError;
    private _handleServerExit;
    /**
     * Send the raw command strings to the cmdserver over `stdin`
     */
    private _serverSend;
}
export {};
