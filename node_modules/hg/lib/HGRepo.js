"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var os = require("os");
var fspath = require("path");
var child_process_1 = require("child_process");
var uuid = require("uuid");
var HGCommandServer_1 = require("./HGCommandServer");
var lodash_1 = require("lodash");
var HGRepo = /** @class */ (function () {
    /**
     * Create a new HGRepo with a rootpath defined
     * by the passed in `@path` (defaults to `process.cwd()`)
     */
    function HGRepo(path) {
        var _this = this;
        this.path = "";
        /**
         * Initialize a new repository at the provided path.
         * Due to limitations of the cmdserver, this must be run from an existing repo.
         */
        this.init = function (initPath, done) {
            var serverCmd = function (server) {
                return server.runcommand("init", initPath);
            };
            return _this._runCommandGetOutput(_this.path, serverCmd, done);
        };
        /**
         * Add files to a repository.
         */
        this.add = function (paths, done) {
            _this.runCommand("add", paths, done);
        };
        /**
         * Commit changes to a repository
         */
        this.commit = function (paths, opts, done) {
            var completePaths = paths, completeOpts = opts, completeDone = done;
            if (lodash_1.isFunction(paths)) {
                completeDone = paths;
                completePaths = [];
            }
            if (lodash_1.isFunction(opts)) {
                completeDone = opts;
                if (lodash_1.isObject(paths)) {
                    completeOpts = paths;
                    completePaths = [];
                }
            }
            return _this.runCommand([
                "commit"
            ].concat(completePaths), completeOpts, completeDone);
        };
        /**
         * Clone a repository.
         * Due to limitations of the cmdserver,
         * this must be run from an existing location.
         */
        this.clone = function (from, to, opts, done) {
            return _this.runCommand(["clone", from, to], opts, done);
        };
        /**
         * Get a summary of the current repository path.
         */
        this.summary = function (opts, done) {
            return _this.runCommand("summary", opts, done);
        };
        /**
         * Get a log of commits for this repository.
         * `opts` is optional and can be either an object or array of arguments.
         */
        this.log = function (opts, done) {
            return _this.runCommand("log", opts, done);
        };
        /**
         * Pull changes from another repository.
         */
        this.pull = function (from, opts, done) {
            return _this.runCommand(["pull", from], opts, done);
        };
        /**
         * Update to the latest changes in a repository.
         */
        this.update = function (opts, done) {
            return _this.runCommand("update", opts, done);
        };
        /**
         * Push changes to another repository
         */
        this.push = function (to, opts, done) {
            return _this.runCommand(["push", to], opts, done);
        };
        /**
         * Merge changes from another repository
         */
        this.merge = function (opts, done) {
            return _this.runCommand("merge", opts, done);
        };
        /**
         * Resolve conflicts in a repository.
         */
        this.resolve = function (opts, done) {
            return _this.runCommand("resolve", opts, done);
        };
        /**
         * Create tags in repo.
         */
        this.tag = function (tagName, opts, done) {
            return _this.runCommand(["tag", tagName], opts, done);
        };
        /**
         * Retrieve repo tags.
         */
        this.tags = function (opts, done) {
            return _this.runCommand("tags", opts, done);
        };
        /**
         * Repo status.
         */
        this.status = function (opts, done) {
            return _this.runCommand("status", opts, done);
        };
        /**
         * Repo branches.
         */
        this.branches = function (opts, done) {
            return _this.runCommand("branches", opts, done);
        };
        /**
         * Repo branch creator.
         */
        this.branch = function (name, opts, done) {
            return _this.runCommand(["branch", name], opts, done);
        };
        /**
         * Repo heads list
         */
        this.heads = function (opts, done) {
            return _this.runCommand("heads", opts, done);
        };
        /**
         * Diff
         */
        this.diff = function (opts, done) {
            return _this.runCommand("diff", opts, done);
        };
        /**
         * Version of hg process
         */
        this.version = function (done) {
            return _this.runCommand("version", done);
        };
        /**
         * Remove files from a repository.
         */
        this.remove = function (paths, done) {
            return _this.runCommand("remove", paths, done);
        };
        /**
         * Execute server command
         * @param args
         * @param opts [Object, Array, String, Function] optional arguments to append
         * to command args. If opts is a function it is treated as the callback function.
         * @param done [Function] callback when command completes
         */
        this.runCommand = function (args, opts, done) {
            var completeDone = done;
            var completeOpts = opts;
            if (lodash_1.isFunction(opts)) {
                completeDone = opts;
                completeOpts = [];
            }
            var completeArgs = typeof args === "string" ? [args] : args;
            completeArgs = completeArgs.concat(_this._parseOptions(completeOpts));
            var serverCmd = function (server) {
                return server.runcommand.apply(server, completeArgs);
            };
            return _this._runCommandGetOutput(_this.path, serverCmd, completeDone);
        };
        /**
         * Parse an object into an array of command line arguments
         */
        this._parseOptions = function (opts) {
            if (lodash_1.isArray(opts)) {
                return opts;
            }
            if (lodash_1.isString(opts)) {
                return [opts];
            }
            var newOpts = [];
            var currKey = "";
            var pushVal = function (value) {
                newOpts.push(currKey);
                if (value) {
                    newOpts.push(value);
                }
            };
            for (var key in opts) {
                if (!opts.hasOwnProperty(key))
                    continue;
                var value = opts[key];
                currKey = key;
                if (lodash_1.isArray(value)) {
                    value.forEach(pushVal);
                }
                else {
                    pushVal(value);
                }
            }
            return newOpts;
        };
        /**
         * Start a command server and return it for use
         */
        this._startServer = function (path, done) {
            var server = new HGCommandServer_1.default();
            return server.start(path, function (err) {
                if (err) {
                    return done(err);
                }
                done(null, server);
            });
        };
        /**
         * Convenience wrapper for starting a command server and executing a command
         */
        this._runCommandGetOutput = function (path, serverAction, done) {
            return _this._startServer(path, function (err, server) {
                if (err) {
                    done(err);
                }
                var cleanUp = function () {
                    server.removeAllListeners("output");
                    return server.removeAllListeners("error");
                };
                var allOutput = [];
                server.on("output", function (body, lines) {
                    return allOutput = allOutput.concat(lines);
                });
                server.on("error", function (err, line) {
                    // Skip warnings, store as output
                    // todo: Allow this to be configured
                    if (line && line.body && line.body.slice(0, 7) === "warning") {
                        allOutput.push(line);
                        return allOutput;
                    }
                    cleanUp();
                    done(err);
                });
                server.once("result", function (body, lines) {
                    if (lines.length) {
                        allOutput = allOutput.concat(lines);
                    }
                    server.stop();
                });
                server.once("exit", function () {
                    cleanUp();
                    done(null, allOutput, server);
                });
                serverAction(server);
            });
        };
        this.path = path || process.cwd();
    }
    /**
     * Create a new repo in a random temp directory.
     * Useful for no-repo commands like init and clone that require a repo
     */
    HGRepo.MakeTempRepo = function (done) {
        var tmpDir = fspath.join(os.tmpdir(), uuid.v1());
        fs.mkdir(tmpDir, function (err) {
            if (err) {
                done(err);
            }
            var initProcess = child_process_1.spawn("hg", ["init"], {
                cwd: tmpDir
            });
            return initProcess.on("exit", function (code) {
                if (code !== 0) {
                    return done(new Error("Non zero status code returned when creating temporary repo: " + code));
                }
                return done(null, new HGRepo(tmpDir));
            });
        });
    };
    return HGRepo;
}());
exports.default = HGRepo;
