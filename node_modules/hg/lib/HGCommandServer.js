"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var child_process_1 = require("child_process");
var _ = require("lodash");
var OutputLine_1 = require("./common/OutputLine");
var defaults = {
    hgOpts: [
        "--config",
        "ui.interactive=True",
        "--config",
        "ui.merge=internal:fail",
        "serve",
        "--cmdserver",
        "pipe"
    ]
};
// add test username to check
if (process.env.NODE_ENV === "test") {
    defaults.hgOpts.push("--config", "ui.username=test");
}
var HGCommandServer = /** @class */ (function (_super) {
    __extends(HGCommandServer, _super);
    function HGCommandServer(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this) || this;
        _this.config = defaults;
        _this.starting = false;
        /**
         * Start the command server at
         * a specified directory (path must already be an hg repository)
         */
        _this.start = function (path, done) {
            return _this._spawnCommandServer(path, done);
        };
        /**
         * Stop the current command server process from running
         */
        _this.stop = function () {
            if (!_this.server) {
                return;
            }
            _this.server.stdout.removeAllListeners("data");
            _this.server.stderr.removeAllListeners("data");
            return _this.server.stdin.end();
        };
        _this.issueCommand = function (cmd) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            _this._serverSend(cmd, args);
        };
        _this._spawnCommandServer = function (path, done) {
            _.bindAll(_this, "_handleServerExit", "_handleServerData");
            _this.starting = true;
            _this.server = _this._makeHgProcess(path);
            // Handle the startup information, then pass off to _handleServerData
            _this.server.stdout.once("data", function (data) {
                _this.starting = false;
                // Parse the Channel information, emit an event on the channel with the data.
                var line = OutputLine_1.default.FromBuffer(data, 0, undefined);
                var _a = _this._parseCapabilitiesAndEncoding(line.body), capabilities = _a.capabilities, encoding = _a.encoding;
                _this.encoding = encoding;
                _this.capabilities = capabilities;
                var _loop_1 = function (capability) {
                    _this[capability] = function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        _this.issueCommand.apply(_this, [capability].concat(args));
                    };
                };
                // Extend the server with shorthand function, ie server.runcommand "summary"
                for (var _i = 0, capabilities_1 = capabilities; _i < capabilities_1.length; _i++) {
                    var capability = capabilities_1[_i];
                    _loop_1(capability);
                }
                // Subscribe the Subsequent data events to our handler
                _this.server && _this.server.stdout.on("data", _this._handleServerData);
                done(null, capabilities, encoding);
            });
            _this.server.stderr.on("data", function (data) {
                if (_this.starting) {
                    return done(new Error(data));
                }
                return _this._handleServerError(data);
            });
            _this.server.on("exit", _this._handleServerExit);
            return _this.server;
        };
        /**
         * Create the child process (exposed for unit testing mostly)
         */
        _this._makeHgProcess = function (path) {
            var processEnv = _.extend({
                HGENCODING: "UTF-8"
            }, process.env);
            var spawnOpts = {
                env: processEnv,
                cwd: path || process.cwd()
            };
            return child_process_1.spawn("hg", _this.config.hgOpts, spawnOpts);
        };
        /**
         * Parse the capabilities and encoding when the cmd server starts up
         */
        _this._parseCapabilitiesAndEncoding = function (data) {
            var fields = {};
            data.split("\n").forEach(function (line) {
                var split = line.split(": ", 2);
                if (split.length === 2) {
                    fields[split[0]] = split[1];
                }
            });
            if (!(fields.capabilities && fields.encoding)) {
                throw new Error("Expected capabilities and encoding: " + data);
            }
            var capabilities = fields.capabilities.split(' ');
            var encoding = fields.encoding;
            return { capabilities: capabilities, encoding: encoding };
        };
        /**
         * Parse the Channel information, emit an event on the channel with the data.
         */
        _this._handleServerData = function (data) {
            var lines = [];
            var body = "";
            var getChanName = function (chan) { return (function () {
                switch (chan) {
                    case "o":
                        return "output";
                    case "r":
                        return "result";
                    case "e":
                        return "error";
                    case "d":
                        return "debug";
                }
                return "output";
            })(); };
            // const chan = String.fromCharCode(data.readUInt8(0));
            var currBuffPos = 0;
            while (currBuffPos < data.length) {
                var line = OutputLine_1.default.FromBuffer(data, currBuffPos, _this.encoding);
                lines.push(line);
                body += line.body + "\n";
                // Increment the buffer position the length
                // of the line + 5 for the channel and bodyLength
                currBuffPos += line.length + 5;
            }
            // Aggregate the channel lines so we can emit the right events per line
            var chanGroups = [];
            var currChan = lines[0].channel;
            var currGroup = [];
            for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                var line = lines_1[_i];
                if (line.channel === currChan) {
                    currGroup.push(line);
                    continue;
                }
                chanGroups.push(currGroup);
                currGroup = [line];
                currChan = line.channel;
            }
            if (currGroup.length > 0) {
                chanGroups.push(currGroup);
            }
            for (var _a = 0, chanGroups_1 = chanGroups; _a < chanGroups_1.length; _a++) {
                var group = chanGroups_1[_a];
                var chanName = getChanName(group[0].channel);
                var body_1 = group.map(function (line) { return line.body; }).join();
                if (chanName === "error") {
                    return _this.emit(chanName, new Error(body_1), group[0], group);
                }
                _this.emit(chanName, body_1, group);
            }
        };
        _this._handleServerError = function (data) {
            // Emit an error event with the data.
            _this.emit("error", data);
        };
        _this._handleServerExit = function (code) {
            // Emit an exit event with the code.
            _this.emit("exit", code);
            // Clean up our listeners
            if (_this.server) {
                _this.server.removeAllListeners("exit");
                _this.server = undefined;
            }
        };
        /**
         * Send the raw command strings to the cmdserver over `stdin`
         */
        _this._serverSend = function (cmd, args) {
            if (args === void 0) { args = []; }
            if (!_this.server) {
                throw new Error("Must start the command server before issuing commands");
            }
            // The space needed by the command (runcommand\n == 11)
            var cmdLength = cmd.length + 1;
            // The space needed for the command arguments
            var argParts = args.join("\0");
            var argLength = argParts.length;
            // The space for declaring the command argument size; always written as 4 bytes
            var argLengthSize = 4;
            // Total up all the sizes to get the buffer length needed
            var totalBufferSize = cmdLength + argLengthSize + argLength;
            // New up our buffer for writing to
            var toWrite = new Buffer(totalBufferSize);
            // Write the command to the buffer
            toWrite.write(cmd + "\n", _this.encoding);
            toWrite.writeUInt32BE(argLength, cmdLength);
            toWrite.write(argParts, cmdLength + argLengthSize, _this.encoding);
            return _this.server.stdin.write(toWrite);
        };
        _this.config = _.defaults(config, _this.config);
        return _this;
    }
    return HGCommandServer;
}(events_1.EventEmitter));
exports.default = HGCommandServer;
